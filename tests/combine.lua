describe('combine', function()
  it('returns the observable it is called on if only the identity function is passed as an argument', function()
    local observable = Rx.Observable.fromRange(1, 5):combine(function(x) return x end)
    expect(observable).to.produce(1, 2, 3, 4, 5)
  end)

  it('should call the combinator function with all values produced from all input observables once they have all produced a value', function()
    local observableA = Rx.Observable.fromValue('a')
    local observableB = Rx.Observable.fromValue('b')
    local observableC = Rx.Observable.fromValue('c')
    local combinator = spy()
    Rx.Observable.combine(observableA, observableB, observableC, function(...) combinator(...) end):subscribe()
    expect(combinator).to.equal({{'a', 'b', 'c'}})
  end)

  it('should emit the return value of the combinator as values', function()
    local observableA = Rx.Subject.create()
    local observableB = Rx.Subject.create()
    local onNext = spy()
    Rx.Observable.combine(observableA, observableB, function(a, b) return a + b end):subscribe(Rx.Observer.create(onNext))
    expect(#onNext).to.equal(0)
    observableA:onNext(1)
    observableB:onNext(2)
    observableB:onNext(3)
    observableA:onNext(4)
    expect(onNext).to.equal({{3}, {4}, {7}})
  end)

  it('should call onComplete once all sources complete', function()
    local observableA = Rx.Subject.create()
    local observableB = Rx.Subject.create()
    local complete = spy()
    Rx.Observable.combine(observableA, observableB, function() end):subscribe(nil, nil, complete)

    expect(#complete).to.equal(0)
    observableA:onNext(1)
    expect(#complete).to.equal(0)
    observableB:onNext(2)
    expect(#complete).to.equal(0)
    observableB:onComplete()
    expect(#complete).to.equal(0)
    observableA:onComplete()
    expect(#complete).to.equal(1)
  end)

  it('should call onError if one source errors', function()
    local observableA = Rx.Subject.create()
    local observableB = Rx.Subject.create()
    local errored = spy()
    Rx.Observable.combine(observableA, observableB, function() end):subscribe(nil, errored)
    expect(#errored).to.equal(0)
    observableB:onError()
    expect(#errored).to.equal(1)
  end)

  it('should error if the combinator is absent', function()
    expect(Rx.Observable.combine(Rx.Observable.fromRange(1, 3)).subscribe).to.fail()
  end)
end)
